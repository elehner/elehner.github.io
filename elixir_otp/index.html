<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
          <h1>Elixir/OTP</h1>
          <h3>Sustainable distributed programming</h3>
        </section>
        <!-- Elixir intro -->
				<section>
          <h2>What is Erlang/OTP?</h2>
					<ul>
						<li>Created at Ericsson</li>
						<li>Created in 1986; Open sourced in 1998</li>
            <li>Focus on fault tolerance and distribution</li>
						<li>Let it crash</li>
					</ul>
          <aside class="notes">
            First prototyped in Prolog.  Joe has a paper descibing Prolog's application to prototyping languages.
          </aside>
        </section>
				<section>
          <h2>What is Elixir?</h2>
					<ul>
						<li>Created by José Valim in 2011</li>
						<li>Ruby inspired, Erlang powered</li>
						<li>Compiles to BEAM Bytecode</li>
					</ul>
        </section>
        <!-- Elixir syntax skim -->
				<section>
          <h2>Basic tenets of Elixir</h2>
          <p>Actually, these are the same for Erlang</p>
					<ul>
						<li>
              Functional
              <ul><li>tail call optimized</li></ul>
            </li>
						<li>Immutable</li>
						<li>Dynamically typed</li>
						<li>Pattern matching</li>
					</ul>
          <aside class="notes">
            Variables can be reused in Elixir, but are bind once in Erlang.
            Immutable Elixir - lists, maps, and structs.
          </aside>
        </section>
				<section>
          <h2>Elixir - Types</h2>
					<ul>
						<li>Ints and floats</li>
            <li>Lists and Maps</li>
						<li>Char lists</li>
            <li>Binaries</li>
						<li>Strings (Binaries)</li>
            <li>Atoms</li>
					</ul>
          <aside class="notes">
            Strings are binaries, allowing them to contain UTF-8 characters.
            Atoms are direct values and not garbage collected. Upper limit exits.
          </aside>
        </section>
				<section>
          <h2>Elixir - Modules and functions</h2>
					<pre><code class="hljs elixir" data-trim contenteditable>
            defmodule Test do
              def hello(:hi), do: :world
              def hello([h|t]), do: {:head, h}
              def hello(_) do
                :why?
              end
            end
            Test.hello(["of_list"]) # returns {:head, "of_list"}
            Test == :"Elixir.Test"
					</code></pre>
          <aside class="notes">
            Module names always begin with a Capital letter. These are technically atoms that are prefixed with "Elixir.".
            All variable, function, and attribute names begin lower-cased
          </aside>
        </section>
				<section>
          <h2>Elixir - Pipes</h2>
					<pre><code class="hljs elixir" data-trim contenteditable>
            third(second(first(param)))
					</code></pre>
          becomes
					<pre><code class="hljs elixir" data-trim contenteditable>
            param |> first |> second |> third
					</code></pre>
          <aside class="notes">
            Mention common styling (new lines)
            First variable piped in, the rest are in parens.
          </aside>
        </section>
				<section>
          <h2>Elixir - Processes</h2>
					<pre><code class="hljs elixir" data-trim contenteditable>
            # Creates a new process that will close when function finishes
            spawn(SomeModule, some_function, [arg1, arg2, etc])
            # Same as above, but if function exits abnormally,
            # it closes the calling process
            spawn_link(SomeModule, some_function, [arg1, arg2, etc])
					</code></pre>
          <aside class="notes">
            If the process exits normally (the call ends) it does not shut down the calling process.
            You can use monitor to avoid linking like this.
          </aside>
        </section>
				<section>
          <h2>Elixir - send and receive</h2>
          <p>Important Elixir/Erlang construct</p>
					<pre><code class="hljs elixir" data-trim contenteditable>
            # Sends a message to itself and then listens for it
            send(self(), :test)
            receive do
              # Pattern matchs messages
              :test -> :response
              # Catch all for unexpected messages
              _ -> :error
            end
					</code></pre>
          <aside class="notes">
            Uncaught messages wait in the mailbox of the process. If the number keeps growing, this can suck up all the memory. Unless you have a good reason not to, all receive loops should end with the catch all.
          </aside>
        </section>
        <!-- OTP intro -->
				<section>
          <h2>What is OTP?</h2>
          <ul>
            <li>Design Patterns</li>
            <li>Tools</li>
            <li>Libraries</li>
            <li class="fragment">Erlang itself</li>
          </ul>
        </section>
				<section>
          <h2>Design Patterns</h2>
          <ul>
            <li>Supervision trees</li>
            <li>Behaviors</li>
            <li>Applications</li>
            <li>Releases & Release Handling</li>
            <li>Nodes and Clusters</li>
          </ul>
        </section>
				<section>
          <h2>Other OTP goodies</h2>
          <ul>
            <li>Management, observations, & monitoring</li>
            <li>Debugging, static analysis, testing</li>
            <li>much more</li>
          </ul>
        </section>
        <!-- Behaviors intro -->
				<section>
          <h2>Behaviors</h2>
          <ul>
            <li>Fomalized common patterns</li>
            <li>Production tested, architect approved</li>
            <li>Consistency</li>
            <li>Fun fact: in erlang it's technically behavio[u]rs</li>
          </ul>
        </section>
				<section>
          <h2>Standard Behaviors</h2>
          <ul>
            <li>
              GenServer (:gen_server)
              <ul>
                <li>Agents & Tasks</li>
              </ul>
            </li>
            <li>GenEvent (:gen_event)</li>
            <li>:gen_statem (replaces :gen_fsm)</li>
            <li>Supervisor (:supervisor)</li>
          </ul>
          <aside class="notes">
            While the following covers out-of-the-box behaviors, you can also make your own.
            Elixir has a few too, like GenStage and Plug
          </aside>
        </section>
        <!-- Behaviors walkthrough -->
          <!-- Simple receive-loop pattern -->
        <section>
          <h2>Simple receive-loop</h2>
          <p>
            A basic Erlang (and Elixir!) structure.
          </p>
					<pre><code class="hljs elixir" data-trim contenteditable>
            defmodule ReceiveLoop do
              ## Stuff ...

              def loop(state) do
                receive do
                  ## Handle Calls
                  :continue -> loop(state)
                  ## Call loop again or exit (Just don't call loop!)
                  :exit -> :ok
                end
              end

              ## More stuff ...
            end
					</code></pre>
        </section>
            <!-- Show loop diagram -->
        <section>
          <h2>Simple receive loop</h2>
          <img src="/images/Receive_Loop.svg"/>
        </section>
            <!-- Show sample loop -->
        <section>
          <h2>Simple receive-loop - KV example</h2>
					<pre><code class="hljs elixir" data-trim contenteditable>
            def loop(map) do # In KeyValue.ReceiveLoop
              receive do
                {:get, sender, key} ->
                  send sender, {:ok, Map.get(map, key)}
                  loop(map)
                {:put, key, value} -> map |> Map.put(key, value) |> loop
                {:delete, sender, key} ->
                  {val, map} =  map |> Map.pop(key)
                  send sender, {:ok, val}
                  loop(map)
                # No loop ends the process
                :stop -> :ok
                _ -> loop(map)
              end
            end

            # How to call the function
            pid = spawn(KeyValue.ReceiveLoop, :loop, [%{}])
            send pid, {:put, "some_key", "some_value"}
          </code></pre>
        </section>
        <section>
          <h2>Simple receive loop</h2>
            <!-- Explain parts of loop that are common -->
          <p>
            You have generic parts such as start, stop, initialize, loop, etc.
          </p>
            <!-- Talk about specific (non-generic) parts -->
          <div  class="fragment">
            <p>
              And specific parts:
            </p>
            <ul>
              <li>Which calls to handle and which to ignore</li>
              <li>How calls should be handled (sync/async)</li>
              <li>What and how to do on teardown on stop</li>
              <li>etc.</li>
            </ul>
          </div>
        </section>
        <section>
          <p>Where do we go from here?</p>
          <img height=500px src="/images/thinking.jpeg"/>
        </section>
        <section>
          <p>There must be a better way</p>
          <img height=500px src="/images/better_way.jpeg"/>
        </section>
          <!-- Expansion into GenServer Behavior -->
            <!-- Cleans up the code -->
            <!-- Catches many edge cases -->
            <!-- Makes life simpler (sync/async handled, messages all caught) -->
            <!-- Elixir defaults (kill the process and show message) -->
				<section>
          <h2>GenServers!</h2>
          <p>The advanced receive-loop</p>
          <ul>
            <li>Formats the code</li>
            <li>Makes life simpler
              <ul>
                <li>Setting up sync/async handled</li>
                <li>All messages caught</li>
                <li>etc.</li>
              </ul>
            </li>
            <li>Catches many edge cases not discussed</li>
            <li>Elixir defaults all required functions for you</li>
          </ul>
          <aside class="notes">
            Catching messages is important. Refer back to receive loop.
            Elixir defaults the required :gen_server functions. In Erlang, the functions are not defaulted, and are required for you to implement each time.
          </aside>
        </section>
        <section>
          <h2>GenServer - KV example</h2>
					<pre><code class="hljs elixir" data-trim contenteditable>
            def init(:ok), do: {:ok, %{}}

            def handle_call({:get, key}, _from, map) do
              {:reply, Map.get(map, key), map}
            end

            def handle_call({:delete, key}, _from, map) do
              {val, new_map} = map |> Map.pop(key)
              {:reply, val, new_map}
            end

            def handle_cast({:put, key, value}, map) do
              {:noreply, Map.put(map, key, value)}
            end
          </code></pre>
          <aside class="notes">
            init initializes the GenServer's state, and returns {:ok, some_state}
            Calls are handled synchronously, and Casts are asynchronous
            There are a few different return tuples possible. The different values are mentioned in one of the cheatsheets linked at the end of the presentation
            _from is not used, but contains {tag}, where tag is a message id.
          </aside>
        </section>
				<section>
          <h2>GenServer - Required callbacks</h2>
          <p>There are actually multiple callbacks (other than init, calls, and casts)</p>
          <ul>
            <li>init, handle_call, handle_cast</li>
            <li>code_change -> called when new code is swapped in; useful for updating state to a new format</li>
            <li>handle_info -> handles other types of messages (not call or cast, but direct)</li>
            <li>terminate -> called when the server is stopped. Useful for cleanup, error logging, etc.</li>
          </ul>
          <aside class="notes">
            I say required because Erlang requires them to be considered in the behvaior spec. There is also format_status, but that is not required by Erlang.
          </aside>
        </section>
        <!-- Explain Supervisor -->
        <section>
          <p>But what happens if it breaks down?...</p>
          <div class="fragment">
            <h2>Supervisors!</h2>
            <img style="border:none; box-shadow:none;" height=450px src="/images/supervisor.jpg"/>
          </div>
        </section>
				<section>
          <h2>Supervisors</h2>
          <p>The managers of OTP (Yes, they are your supervisor...)</p>
          <ul>
            <li>Monitors "worker" processes</li>
            <li>Can be used to startup said processes</li>
            <li>Should something break, can selectively restart processes</li>
            <li>The supervisor may also not want to restart the process</li>
            <li>Has multiple restart patterns (strategies)</li>
          </ul>
          <aside class="notes">
            Processes can be labelled temporary and are not restarted.
          </aside>
        </section>
          <!-- Different restart modes -->
				<section>
          <h2>Supervision Strategies</h2>
          <ul>
            <li>:one_for_one -> when a child process terminates, restart only that one</li>
            <li>:one_for_all -> when a child process terminates, restart all</li>
            <li>:rest_for_one -> when a child process terminates, restart that one and all others started after it</li>
            <li>:simple_one_for_one -> variation of :one_for_one; all processes are started dynamically, and share the same base class.</li>
          </ul>
          <aside class="notes">
            For :simple_one_for_one, a decent example is DB connections, where connections should be dynamically added over time rather than instantiating one and just using that.
          </aside>
        </section>
          <!-- Supervision trees to maintain the whole application -->
				<section>
          <h2>Supervision Trees</h2>
          <p>Supervision is rarely done by one process</p>
          <ul>
            <li>Supervisors for supervisors</li>
            <li>Multiple supervisors provide failure isolation</li>
            <li>Supervisors are restarted themselves should something go wrong</li>
          </ul>
          <aside class="notes">
            A case where something goes wrong with the supervisor: a supervised module is failing continuously.
            Supervisors have a max number of restarts for children
            If limit is exceeded, they shut down themselves
            Their supervisor attempts to restart them
            If it reaches the limit, it just goes up the tree...
            This continues until the VM is restarted, or the child that failed is considered "temporary" and no restarts are tried.
          </aside>
        </section>
        <section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree.svg"/>
          </section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree_failure.svg"/>
          </section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree_restart.svg"/>
          </section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree.svg"/>
          </section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree_failure.svg"/>
          </section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree_restart.svg"/>
          </section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree_failure.svg"/>
          </section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree_multi_failure.svg"/>
          </section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree_restart_sup.svg"/>
          </section>
          <section>
            <h2>Supervision Trees</h2>
            <img style="border:none; box-shadow:none;" src="/images/supervision_tree/supervision_tree.svg"/>
          </section>
        </section>
          <!-- Diagram? -->
        <!-- Fin -->
          <!-- What else is there to learn about? (everything) -->
        <section>
          <h2>What else is there to learn about?</h2>
          <p>Lots...</p>
          <ul>
            <li>All the behaviors I didn't talk about</li>
            <li>Application creation</li>
            <li>Deployment</li>
            <li>Release management</li>
            <li>...</li>
          </ul>
        </section>
        <section>
          <h2>Where can I learn more?</h2>
          <p>Tons of places!</p>
          <ul>
            <li><a href="http://elixir-lang.org/">Elixir Homepage</a></li>
            <li><a href="http://www.erlang.org/">Erlang Homepage</a></li>
            <li><a href="http://learnyousomeerlang.com/">Learn You Some Erlang</a></li>
            <li><a href="https://www.manning.com/books/the-little-elixir-and-otp-guidebook">The Little Elixir & OTP Guidebook</a></li>
            <li><a href="http://shop.oreilly.com/product/0636920024149.do">Designing for Scalability with Erlang/OTP</a></li>
            <li><a href="https://www.google.com/">The Fountain of All Knowledge</a></li>
          </ul>
        </section>
          <!-- Thanks and credits -->
        <section>
          <h2>What inspired this presentation?</h2>
          <p>Besides the previous sources</p
          <ul>
            <li><a href="https://www.youtube.com/watch?v=PkHZPTn1brc">A Peek Inside Erlang's OTP • Steve Vinoski</a></li>
            <li><a href="https://www.youtube.com/watch?v=4SCwubzqsVU">The ABCs of OTP - Jesse J. Anderson</a></li>
          </ul>
        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
